# JavaScript Control Transfer Statements

**Control Transfer Statements** (also called **Unconditional** or **Branching** statements) are used to transfer the control of execution from one part of the program to another. They alter the normal sequential flow of execution.

---

## üìë Table of Contents

- [JavaScript Control Transfer Statements](#javascript-control-transfer-statements)
  - [üìë Table of Contents](#-table-of-contents)
  - [What are Control Transfer Statements?](#what-are-control-transfer-statements)
    - [Flow Diagram:](#flow-diagram)
  - [Types of Control Transfer Statements](#types-of-control-transfer-statements)
  - [break Statement](#break-statement)
    - [1. break in switch Block](#1-break-in-switch-block)
      - [Example 1: With break (Correct)](#example-1-with-break-correct)
      - [Example 2: Without break (Fall-Through)](#example-2-without-break-fall-through)
    - [2. break in for Loop](#2-break-in-for-loop)
      - [Syntax:](#syntax)
      - [Example 1: Exit Loop at Specific Value](#example-1-exit-loop-at-specific-value)
      - [Example 2: Find First Match and Stop](#example-2-find-first-match-and-stop)
      - [Example 3: Stop When Sum Exceeds Limit](#example-3-stop-when-sum-exceeds-limit)
    - [3. break in while Loop](#3-break-in-while-loop)
      - [Syntax:](#syntax-1)
      - [Example:](#example)
      - [Example: Search with while](#example-search-with-while)
    - [4. break in do...while Loop](#4-break-in-dowhile-loop)
      - [Syntax:](#syntax-2)
      - [Example:](#example-1)
    - [5. break in for...of Loop](#5-break-in-forof-loop)
    - [6. break with Labels](#6-break-with-labels)
      - [Syntax:](#syntax-3)
      - [Example 1: Breaking Out of Nested Loops](#example-1-breaking-out-of-nested-loops)
      - [Example 2: Without Label vs With Label](#example-2-without-label-vs-with-label)
      - [Example 3: Search in 2D Array](#example-3-search-in-2d-array)
  - [continue Statement](#continue-statement)
    - [1. continue in for Loop](#1-continue-in-for-loop)
      - [Syntax:](#syntax-4)
      - [Example 1: Skip Even Numbers](#example-1-skip-even-numbers)
      - [Example 2: Skip Specific Value](#example-2-skip-specific-value)
      - [Example 3: Process Only Valid Items](#example-3-process-only-valid-items)
    - [2. continue in while Loop](#2-continue-in-while-loop)
      - [Syntax:](#syntax-5)
      - [Example 1: Print Odd Numbers](#example-1-print-odd-numbers)
      - [Example 2: Common Mistake with while + continue](#example-2-common-mistake-with-while--continue)
    - [3. continue in do...while Loop](#3-continue-in-dowhile-loop)
    - [4. continue in for...of Loop](#4-continue-in-forof-loop)
    - [5. continue with Labels](#5-continue-with-labels)
      - [Syntax:](#syntax-6)
      - [Example:](#example-2)
      - [Example: Skip Rows with Invalid Data](#example-skip-rows-with-invalid-data)
  - [break vs continue](#break-vs-continue)
    - [Visual Comparison:](#visual-comparison)
  - [return Statement](#return-statement)
    - [Syntax:](#syntax-7)
    - [Example 1: Basic return](#example-1-basic-return)
    - [Example 2: Early return (Guard Clause)](#example-2-early-return-guard-clause)
    - [Example 3: return in Loops](#example-3-return-in-loops)
    - [Example 4: return Without a Value](#example-4-return-without-a-value)
    - [Example 5: return with Different Data Types](#example-5-return-with-different-data-types)
    - [‚ö†Ô∏è return and Automatic Semicolon Insertion (ASI)](#Ô∏è-return-and-automatic-semicolon-insertion-asi)
  - [throw Statement](#throw-statement)
    - [Syntax:](#syntax-8)
    - [Example 1: Throwing Errors](#example-1-throwing-errors)
    - [Example 2: throw with Custom Error Types](#example-2-throw-with-custom-error-types)
    - [Example 3: throw in Validation](#example-3-throw-in-validation)
    - [Example 4: Custom Error Class](#example-4-custom-error-class)
  - [try...catch...finally](#trycatchfinally)
    - [Syntax:](#syntax-9)
    - [Example 1: Basic try...catch](#example-1-basic-trycatch)
    - [Example 2: try...catch...finally](#example-2-trycatchfinally)
    - [Example 3: Catching Specific Errors](#example-3-catching-specific-errors)
    - [Example 4: Nested try...catch](#example-4-nested-trycatch)
    - [Example 5: finally Always Runs](#example-5-finally-always-runs)
  - [Labeled Statements (Deep Dive)](#labeled-statements-deep-dive)
    - [Rules:](#rules)
    - [Example: Labeled Block Statement](#example-labeled-block-statement)
    - [Example: Practical Use ‚Äî Find First Pair Summing to Target](#example-practical-use--find-first-pair-summing-to-target)
  - [Best Practices](#best-practices)
    - [‚úÖ Do:](#-do)
  - [Common Mistakes to Avoid](#common-mistakes-to-avoid)
    - [‚ùå Don't:](#-dont)
  - [Practical Examples](#practical-examples)
    - [Example 1: Input Validation with break](#example-1-input-validation-with-break)
    - [Example 2: Filter with continue](#example-2-filter-with-continue)
    - [Example 3: Safe API Call with try...catch](#example-3-safe-api-call-with-trycatch)
    - [Example 4: Retry Logic with Loops and throw](#example-4-retry-logic-with-loops-and-throw)
    - [Example 5: All Statements Combined](#example-5-all-statements-combined)
  - [Comparison Table](#comparison-table)
    - [All Control Transfer Statements:](#all-control-transfer-statements)
    - [break vs continue vs return:](#break-vs-continue-vs-return)
    - [Error Handling:](#error-handling)
  - [Summary](#summary)
    - [Key Takeaways:](#key-takeaways)

---

## What are Control Transfer Statements?

**Control Transfer Statements** change the normal flow of program execution. Instead of running code line by line, these statements allow you to:

- **Exit** a loop or switch early (`break`)
- **Skip** the current iteration (`continue`)
- **Exit** a function and return a value (`return`)
- **Signal** an error (`throw`)

### Flow Diagram:
```
Normal Flow:      With break:       With continue:     With return:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Code ‚îÇ          ‚îÇ Code ‚îÇ          ‚îÇ Code ‚îÇ           ‚îÇ Code ‚îÇ
‚îÇ  ‚Üì   ‚îÇ          ‚îÇ  ‚Üì   ‚îÇ          ‚îÇ  ‚Üì   ‚îÇ           ‚îÇ  ‚Üì   ‚îÇ
‚îÇ Loop ‚îÇ          ‚îÇ Loop ‚îÇ          ‚îÇ Loop ‚îÇ           ‚îÇ func ‚îÇ
‚îÇ  ‚Üì   ‚îÇ          ‚îÇ  ‚Üì break ‚îÄ‚îÄ‚ñ∫   ‚îÇ  ‚Üì continue      ‚îÇ  ‚Üì return ‚îÄ‚îÄ‚ñ∫
‚îÇ Code ‚îÇ          ‚îÇ Code ‚îÇ     ‚îÇ    ‚îÇ  ‚Üë   ‚îÇ     ‚îÇ     ‚îÇ Code ‚îÇ     ‚îÇ
‚îÇ  ‚Üì   ‚îÇ          ‚îÇ  ‚Üì   ‚îÇ     ‚îÇ    ‚îÇ  ‚Üì   ‚îÇ     ‚îÇ     ‚îÇ  ‚Üì   ‚îÇ     ‚îÇ
‚îÇ End  ‚îÇ          ‚îÇ End  ‚îÇ ‚óÑ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ End  ‚îÇ     ‚îÇ     ‚îÇ End  ‚îÇ     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
                                      ‚Üë‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       Caller ‚óÑ‚îÄ‚îÄ‚îò
```

---

## Types of Control Transfer Statements

| # | Statement | Description | Used In |
|---|-----------|-------------|---------|
| 1 | `break` | Exits the current loop or switch entirely | `for`, `while`, `do...while`, `for...in`, `for...of`, `switch` |
| 2 | `continue` | Skips the current iteration, jumps to the next | `for`, `while`, `do...while`, `for...in`, `for...of` |
| 3 | `return` | Exits the current function and optionally returns a value | Functions |
| 4 | `throw` | Throws an error/exception that can be caught | Anywhere |

---

## break Statement

The `break` statement is used to **terminate** the execution of a loop or switch statement immediately. When `break` is encountered, control passes to the statement following the loop or switch.

---

### 1. break in switch Block

Without `break`, the switch statement **falls through** to the next case.

#### Example 1: With break (Correct)
```javascript
const fruit = "Apple";

switch (fruit) {
    case "Apple":
        console.log("Apple is healthy.");
        break;  // Exits the switch
    case "Mango":
        console.log("Mango is delicious.");
        break;
    default:
        console.log("No fruit chosen.");
}
// Output: Apple is healthy.
```

#### Example 2: Without break (Fall-Through)
```javascript
const fruit = "Apple";

switch (fruit) {
    case "Apple":
        console.log("Apple is healthy.");
        // ‚ö†Ô∏è No break ‚Äî falls through to next case!
    case "Mango":
        console.log("Mango is delicious.");
        break;
    default:
        console.log("No fruit chosen.");
}
// Output:
// Apple is healthy.
// Mango is delicious.
// ‚ö†Ô∏è Both lines print because of missing break!
```

---

### 2. break in for Loop

#### Syntax:
```javascript
for (init; condition; update) {
    // code
    if (conditionToBreak) {
        break;
    }
    // code
}
```

#### Example 1: Exit Loop at Specific Value
```javascript
for (let i = 1; i < 6; i++) {
    if (i === 4) break;  // Exit when i reaches 4
    console.log(i);
}
// Output:
// 1
// 2
// 3
```

#### Example 2: Find First Match and Stop
```javascript
let names = ["Alice", "Bob", "Charlie", "David", "Eve"];

for (let i = 0; i < names.length; i++) {
    if (names[i] === "Charlie") {
        console.log(`Found Charlie at index ${i}`);
        break;
    }
}
// Output: Found Charlie at index 2
```

#### Example 3: Stop When Sum Exceeds Limit
```javascript
let numbers = [10, 20, 30, 40, 50];
let sum = 0;

for (let num of numbers) {
    if (sum + num > 50) {
        console.log(`Stopped! Adding ${num} would exceed 50.`);
        break;
    }
    sum += num;
}

console.log(`Sum: ${sum}`);
// Output:
// Stopped! Adding 30 would exceed 50.
// Sum: 30
```

---

### 3. break in while Loop

#### Syntax:
```javascript
while (condition) {
    // code
    if (conditionToBreak) {
        break;
    }
    // code
}
```

#### Example:
```javascript
let i = 1;

while (i <= 5) {
    console.log(i);
    if (i === 3) {
        break;  // Exit when i reaches 3
    }
    i++;
}
// Output:
// 1
// 2
// 3
```

#### Example: Search with while
```javascript
let data = [5, 12, 8, 130, 44];
let index = 0;
let found = false;

while (index < data.length) {
    if (data[index] > 100) {
        console.log(`Found value > 100: ${data[index]} at index ${index}`);
        found = true;
        break;
    }
    index++;
}

if (!found) console.log("No value greater than 100");
// Output: Found value > 100: 130 at index 3
```

---

### 4. break in do...while Loop

#### Syntax:
```javascript
do {
    // code
    if (conditionToBreak) {
        break;
    }
    // code
} while (condition);
```

#### Example:
```javascript
let j = 1;

do {
    console.log(j);
    if (j === 3) {
        break;  // Exit when j reaches 3
    }
    j++;
} while (j <= 5);
// Output:
// 1
// 2
// 3
```

---

### 5. break in for...of Loop

```javascript
let fruits = ["Apple", "Banana", "Cherry", "Date", "Elderberry"];

for (let fruit of fruits) {
    if (fruit === "Cherry") {
        console.log(`Found: ${fruit}! Stopping search.`);
        break;
    }
    console.log(`Checking: ${fruit}...`);
}
// Output:
// Checking: Apple...
// Checking: Banana...
// Found: Cherry! Stopping search.
```

---

### 6. break with Labels

In JavaScript, we can use a `break` statement with a **label** to exit from a specific outer loop, even when nested inside another loop. Without a label, `break` only exits the **innermost** loop.

#### Syntax:
```javascript
labelName: for (...) {
    for (...) {
        if (condition) {
            break labelName;  // Exits the OUTER loop
        }
    }
}
```

#### Example 1: Breaking Out of Nested Loops
```javascript
outerLoop:
for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (i === 1 && j === 1) {
            break outerLoop;  // Exits BOTH loops
        }
        console.log(`i: ${i}, j: ${j}`);
    }
}
// Output:
// i: 0, j: 0
// i: 0, j: 1
// i: 0, j: 2
// i: 1, j: 0
// (Stopped at i=1, j=1)
```

#### Example 2: Without Label vs With Label
```javascript
// Without label ‚Äî only breaks inner loop
console.log("Without label:");
for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (j === 1) break;  // Only exits inner loop
        console.log(`i: ${i}, j: ${j}`);
    }
}
// Output:
// i: 0, j: 0
// i: 1, j: 0
// i: 2, j: 0  ‚Üê outer loop continues!

// With label ‚Äî breaks outer loop entirely
console.log("With label:");
outer:
for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (j === 1) break outer;  // Exits both loops
        console.log(`i: ${i}, j: ${j}`);
    }
}
// Output:
// i: 0, j: 0  ‚Üê only this prints, then both loops exit
```

#### Example 3: Search in 2D Array
```javascript
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
let target = 5;
let found = false;

search:
for (let row = 0; row < matrix.length; row++) {
    for (let col = 0; col < matrix[row].length; col++) {
        if (matrix[row][col] === target) {
            console.log(`Found ${target} at position [${row}][${col}]`);
            found = true;
            break search;
        }
    }
}
// Output: Found 5 at position [1][1]
```

---

## continue Statement

The `continue` statement is used to **skip the current iteration** of a loop and jump to the **next iteration**. Unlike `break`, it does not exit the loop entirely.

---

### 1. continue in for Loop

#### Syntax:
```javascript
for (init; condition; update) {
    // code
    if (conditionToSkip) {
        continue;  // Skip rest of body, go to update step
    }
    // code (skipped when continue runs)
}
```

#### Example 1: Skip Even Numbers
```javascript
for (let i = 0; i < 10; i++) {
    if (i % 2 === 0) continue;  // Skip even numbers
    console.log(i);
}
// Output:
// 1
// 3
// 5
// 7
// 9
```

#### Example 2: Skip Specific Value
```javascript
for (let i = 1; i <= 5; i++) {
    if (i === 3) continue;  // Skip 3
    console.log(i);
}
// Output: 1, 2, 4, 5
```

#### Example 3: Process Only Valid Items
```javascript
let scores = [85, -1, 90, 0, 78, -5, 92];

for (let i = 0; i < scores.length; i++) {
    if (scores[i] <= 0) continue;  // Skip invalid scores
    console.log(`Valid score: ${scores[i]}`);
}
// Output:
// Valid score: 85
// Valid score: 90
// Valid score: 78
// Valid score: 92
```

---

### 2. continue in while Loop

#### Syntax:
```javascript
while (condition) {
    // code
    if (conditionToSkip) {
        continue;  // Jump back to condition check
    }
    // code (skipped when continue runs)
}
```

> **‚ö†Ô∏è Warning:** When using `continue` in a `while` loop, make sure the counter is updated **before** the `continue` statement, or you'll create an infinite loop!

#### Example 1: Print Odd Numbers
```javascript
let i = 0;

while (i < 11) {
    i++;  // ‚úÖ Update BEFORE continue
    if (i % 2 === 0) continue;
    console.log(i);
}
// Output: 1, 3, 5, 7, 9, 11
```

#### Example 2: Common Mistake with while + continue
```javascript
// ‚ùå BAD ‚Äî infinite loop!
let j = 0;
while (j < 5) {
    if (j === 3) {
        continue;  // j is never incremented, stuck at 3 forever!
    }
    console.log(j);
    j++;
}

// ‚úÖ GOOD ‚Äî increment before continue
let k = 0;
while (k < 5) {
    k++;
    if (k === 3) {
        continue;  // k already incremented, safe!
    }
    console.log(k);
}
// Output: 1, 2, 4, 5
```

---

### 3. continue in do...while Loop

```javascript
let num = 0;

do {
    num++;
    if (num % 3 === 0) continue;  // Skip multiples of 3
    console.log(num);
} while (num < 10);
// Output: 1, 2, 4, 5, 7, 8, 10
```

---

### 4. continue in for...of Loop

```javascript
let words = ["hello", "", "world", null, "JavaScript", undefined, "rocks"];

for (let word of words) {
    if (!word) continue;  // Skip falsy values
    console.log(word.toUpperCase());
}
// Output:
// HELLO
// WORLD
// JAVASCRIPT
// ROCKS
```

```javascript
// Skip short words
let sentence = ["I", "love", "JavaScript", "and", "it", "is", "awesome"];

for (let word of sentence) {
    if (word.length <= 2) continue;
    console.log(word);
}
// Output: love, JavaScript, and, awesome
```

---

### 5. continue with Labels

Similar to `break` with labels, `continue` with a label skips to the next iteration of the **labeled (outer) loop**.

#### Syntax:
```javascript
labelName: for (...) {
    for (...) {
        if (condition) {
            continue labelName;  // Skip to next iteration of OUTER loop
        }
    }
}
```

#### Example:
```javascript
outer:
for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (j === 1) {
            continue outer;  // Skip rest of inner loop, go to next i
        }
        console.log(`i: ${i}, j: ${j}`);
    }
}
// Output:
// i: 0, j: 0
// i: 1, j: 0
// i: 2, j: 0
// (j never reaches 2 because continue outer triggers at j=1)
```

#### Example: Skip Rows with Invalid Data
```javascript
let table = [
    [1, 2, 3],
    [4, null, 6],
    [7, 8, 9]
];

rowLoop:
for (let i = 0; i < table.length; i++) {
    for (let j = 0; j < table[i].length; j++) {
        if (table[i][j] === null) {
            console.log(`Skipping row ${i} (contains null)`);
            continue rowLoop;
        }
    }
    console.log(`Row ${i}: ${table[i].join(", ")}`);
}
// Output:
// Row 0: 1, 2, 3
// Skipping row 1 (contains null)
// Row 2: 7, 8, 9
```

---

## break vs continue

| Feature | `break` | `continue` |
|---------|---------|------------|
| **Action** | **Exits** the entire loop | **Skips** current iteration |
| **Loop continues?** | ‚ùå No ‚Äî loop ends | ‚úÖ Yes ‚Äî next iteration runs |
| **Works in switch?** | ‚úÖ Yes | ‚ùå No |
| **Works with labels?** | ‚úÖ Yes | ‚úÖ Yes |
| **Use case** | Stop searching after finding result | Filter/skip unwanted items |

### Visual Comparison:
```javascript
console.log("=== break ===");
for (let i = 1; i <= 5; i++) {
    if (i === 3) break;
    console.log(i);
}
// Output: 1, 2
// (Loop STOPS at 3)

console.log("=== continue ===");
for (let i = 1; i <= 5; i++) {
    if (i === 3) continue;
    console.log(i);
}
// Output: 1, 2, 4, 5
// (3 is SKIPPED, loop continues)
```

---

## return Statement

The `return` statement **exits a function** and optionally sends a value back to the caller. It immediately stops the function execution.

### Syntax:
```javascript
return;         // Returns undefined
return value;   // Returns the specified value
```

> **Note:** `return` can only be used inside a **function**. Using it outside a function causes a `SyntaxError`.

### Example 1: Basic return
```javascript
function add(a, b) {
    return a + b;  // Returns the sum and exits
}

let result = add(5, 3);
console.log(result);  // 8
```

### Example 2: Early return (Guard Clause)
```javascript
// Without early return ‚Äî deeply nested
function processAge(age) {
    if (typeof age === "number") {
        if (age >= 0) {
            if (age < 150) {
                return `Valid age: ${age}`;
            } else {
                return "Age too high";
            }
        } else {
            return "Age cannot be negative";
        }
    } else {
        return "Age must be a number";
    }
}

// With early return ‚Äî flat and clean ‚úÖ
function processAgeClean(age) {
    if (typeof age !== "number") return "Age must be a number";
    if (age < 0) return "Age cannot be negative";
    if (age >= 150) return "Age too high";
    return `Valid age: ${age}`;
}

console.log(processAgeClean(25));     // "Valid age: 25"
console.log(processAgeClean(-5));     // "Age cannot be negative"
console.log(processAgeClean("abc"));  // "Age must be a number"
```

### Example 3: return in Loops
```javascript
function findIndex(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i;  // Exits BOTH the loop AND the function
        }
    }
    return -1;  // Not found
}

console.log(findIndex([10, 20, 30, 40], 30));  // 2
console.log(findIndex([10, 20, 30, 40], 50));  // -1
```

### Example 4: return Without a Value
```javascript
function greet(name) {
    if (!name) {
        console.log("No name provided");
        return;  // Exits function, returns undefined
    }
    console.log(`Hello, ${name}!`);
}

greet("Alice");  // "Hello, Alice!"
greet("");       // "No name provided"

let result = greet("");
console.log(result);  // undefined
```

### Example 5: return with Different Data Types
```javascript
function getUser() {
    return {                    // Return an object
        name: "Alice",
        age: 25
    };
}

function getScores() {
    return [90, 85, 78, 92];   // Return an array
}

function isAdult(age) {
    return age >= 18;           // Return a boolean
}

console.log(getUser());      // { name: "Alice", age: 25 }
console.log(getScores());    // [90, 85, 78, 92]
console.log(isAdult(20));    // true
```

### ‚ö†Ô∏è return and Automatic Semicolon Insertion (ASI)
```javascript
// ‚ùå BAD ‚Äî return and value on different lines
function badReturn() {
    return       // JS inserts semicolon here! ‚Üí return;
    {
        name: "Alice"
    };
}
console.log(badReturn());  // undefined! üò±

// ‚úÖ GOOD ‚Äî opening brace on same line as return
function goodReturn() {
    return {
        name: "Alice"
    };
}
console.log(goodReturn());  // { name: "Alice" }
```

---

## throw Statement

The `throw` statement **throws a user-defined exception** (error). It stops the current function execution and passes control to the first `catch` block in the call stack.

### Syntax:
```javascript
throw expression;  // Can throw any value (string, number, object, Error)
```

### Example 1: Throwing Errors
```javascript
// Throw a string (not recommended)
// throw "Something went wrong";

// Throw an Error object (recommended)
// throw new Error("Something went wrong");

function divide(a, b) {
    if (b === 0) {
        throw new Error("Cannot divide by zero!");
    }
    return a / b;
}

try {
    console.log(divide(10, 2));   // 5
    console.log(divide(10, 0));   // Throws error!
} catch (error) {
    console.log(`Error: ${error.message}`);
}
// Output:
// 5
// Error: Cannot divide by zero!
```

### Example 2: throw with Custom Error Types
```javascript
// Built-in Error Types
// throw new TypeError("Expected a string");
// throw new RangeError("Value out of range");
// throw new ReferenceError("Variable not found");
// throw new SyntaxError("Invalid syntax");

function setAge(age) {
    if (typeof age !== "number") {
        throw new TypeError("Age must be a number");
    }
    if (age < 0 || age > 150) {
        throw new RangeError("Age must be between 0 and 150");
    }
    return age;
}

try {
    setAge("abc");
} catch (e) {
    console.log(`${e.name}: ${e.message}`);
}
// Output: TypeError: Age must be a number

try {
    setAge(200);
} catch (e) {
    console.log(`${e.name}: ${e.message}`);
}
// Output: RangeError: Age must be between 0 and 150
```

### Example 3: throw in Validation
```javascript
function validateEmail(email) {
    if (!email) {
        throw new Error("Email is required");
    }
    if (!email.includes("@")) {
        throw new Error("Invalid email format: missing @");
    }
    if (!email.includes(".")) {
        throw new Error("Invalid email format: missing domain");
    }
    return true;
}

try {
    validateEmail("john@example.com");
    console.log("Email is valid ‚úÖ");
} catch (error) {
    console.log(`Validation failed: ${error.message}`);
}
// Output: Email is valid ‚úÖ

try {
    validateEmail("invalid-email");
    console.log("Email is valid ‚úÖ");
} catch (error) {
    console.log(`Validation failed: ${error.message}`);
}
// Output: Validation failed: Invalid email format: missing @
```

### Example 4: Custom Error Class
```javascript
class ValidationError extends Error {
    constructor(field, message) {
        super(message);
        this.name = "ValidationError";
        this.field = field;
    }
}

function validateUser(user) {
    if (!user.name) {
        throw new ValidationError("name", "Name is required");
    }
    if (!user.email) {
        throw new ValidationError("email", "Email is required");
    }
    if (user.age < 0) {
        throw new ValidationError("age", "Age cannot be negative");
    }
}

try {
    validateUser({ name: "", email: "test@test.com", age: 25 });
} catch (error) {
    if (error instanceof ValidationError) {
        console.log(`Field: ${error.field}, Error: ${error.message}`);
    }
}
// Output: Field: name, Error: Name is required
```

---

## try...catch...finally

The `try...catch...finally` block handles errors gracefully, preventing the program from crashing.

### Syntax:
```javascript
try {
    // Code that might throw an error
} catch (error) {
    // Code to handle the error
} finally {
    // Code that ALWAYS runs (optional)
}
```

### Example 1: Basic try...catch
```javascript
try {
    let result = JSON.parse("invalid json");
} catch (error) {
    console.log("Error caught!");
    console.log(`Type: ${error.name}`);
    console.log(`Message: ${error.message}`);
}
// Output:
// Error caught!
// Type: SyntaxError
// Message: Unexpected token 'i', "invalid json" is not valid JSON
```

### Example 2: try...catch...finally
```javascript
function readData() {
    console.log("Opening connection...");
    try {
        console.log("Reading data...");
        throw new Error("Network error");
        console.log("This never runs");
    } catch (error) {
        console.log(`Error: ${error.message}`);
    } finally {
        console.log("Closing connection...");  // ALWAYS runs
    }
}

readData();
// Output:
// Opening connection...
// Reading data...
// Error: Network error
// Closing connection...
```

### Example 3: Catching Specific Errors
```javascript
function processInput(input) {
    try {
        let data = JSON.parse(input);

        if (!data.name) {
            throw new TypeError("Name is required");
        }
        if (data.age < 0) {
            throw new RangeError("Age cannot be negative");
        }

        console.log(`Processed: ${data.name}, age ${data.age}`);
    } catch (error) {
        if (error instanceof SyntaxError) {
            console.log("Invalid JSON format");
        } else if (error instanceof TypeError) {
            console.log(`Type Error: ${error.message}`);
        } else if (error instanceof RangeError) {
            console.log(`Range Error: ${error.message}`);
        } else {
            console.log(`Unknown Error: ${error.message}`);
        }
    }
}

processInput('{"name": "Alice", "age": 25}');  // Processed: Alice, age 25
processInput('bad json');                        // Invalid JSON format
processInput('{"age": 25}');                     // Type Error: Name is required
processInput('{"name": "Bob", "age": -5}');     // Range Error: Age cannot be negative
```

### Example 4: Nested try...catch
```javascript
try {
    try {
        throw new Error("Inner error");
    } catch (innerError) {
        console.log(`Inner catch: ${innerError.message}`);
        throw new Error("Re-thrown error");  // Re-throw to outer
    }
} catch (outerError) {
    console.log(`Outer catch: ${outerError.message}`);
}
// Output:
// Inner catch: Inner error
// Outer catch: Re-thrown error
```

### Example 5: finally Always Runs
```javascript
function test(value) {
    try {
        if (value === 0) throw new Error("Zero!");
        return `Success: ${value}`;
    } catch (e) {
        return `Error: ${e.message}`;
    } finally {
        console.log("Finally block runs!");  // Runs regardless
    }
}

console.log(test(5));
// Output:
// Finally block runs!
// Success: 5

console.log(test(0));
// Output:
// Finally block runs!
// Error: Zero!
```

---

## Labeled Statements (Deep Dive)

Labels let you target a specific loop with `break` or `continue` in nested structures.

### Rules:
- Labels must be valid identifiers followed by a colon `:`
- Labels only work with `break` and `continue`
- A label can only reference a loop (for, while, do...while, for...in, for...of) or a block statement
- `break` with a label can target any labeled statement; `continue` with a label can only target loops

### Example: Labeled Block Statement
```javascript
// break can target labeled blocks (not just loops)
myBlock: {
    console.log("Before break");
    break myBlock;
    console.log("After break");  // Never runs
}
console.log("After block");
// Output:
// Before break
// After block
```

### Example: Practical Use ‚Äî Find First Pair Summing to Target
```javascript
let numbers = [1, 5, 3, 8, 2, 7];
let target = 10;

findPair:
for (let i = 0; i < numbers.length; i++) {
    for (let j = i + 1; j < numbers.length; j++) {
        if (numbers[i] + numbers[j] === target) {
            console.log(`Pair found: ${numbers[i]} + ${numbers[j]} = ${target}`);
            break findPair;
        }
    }
}
// Output: Pair found: 5 + 5 = 10? Actually: Pair found: 3 + 7 = 10
```

---

## Best Practices

### ‚úÖ Do:

1. **Always Include `break` in switch Cases**
   ```javascript
   switch (action) {
       case "save":
           saveData();
           break;
       case "delete":
           deleteData();
           break;
       default:
           console.log("Unknown action");
   }
   ```

2. **Use Early `return` Instead of Deep Nesting**
   ```javascript
   // Good ‚Äî guard clauses
   function process(data) {
       if (!data) return null;
       if (!data.valid) return "Invalid";
       return data.value * 2;
   }
   ```

3. **Throw Error Objects, Not Strings**
   ```javascript
   // ‚úÖ Good ‚Äî has name, message, stack trace
   throw new Error("Something went wrong");

   // ‚ùå Avoid ‚Äî no stack trace, no name property
   // throw "Something went wrong";
   ```

4. **Always Handle Errors with try...catch**
   ```javascript
   // ‚úÖ Guard risky operations
   try {
       let data = JSON.parse(userInput);
   } catch (error) {
       console.error("Invalid input:", error.message);
   }
   ```

5. **Use `finally` for Cleanup**
   ```javascript
   let file;
   try {
       file = openFile("data.txt");
       processFile(file);
   } catch (error) {
       console.error(error);
   } finally {
       if (file) closeFile(file);  // Always clean up
   }
   ```

6. **Use `continue` to Reduce Nesting**
   ```javascript
   // ‚úÖ Good ‚Äî skip invalid, process rest
   for (let item of items) {
       if (!item.active) continue;
       if (!item.visible) continue;
       processItem(item);
   }

   // ‚ùå Avoid ‚Äî deeply nested
   for (let item of items) {
       if (item.active) {
           if (item.visible) {
               processItem(item);
           }
       }
   }
   ```

7. **Place Counter Update Before `continue` in while Loops**
   ```javascript
   let i = 0;

   while (i < 10) {
       i++;  // ‚úÖ Update BEFORE continue
       if (someCondition) continue;
       doSomething();
   }
   ```

---

## Common Mistakes to Avoid

### ‚ùå Don't:

1. **Don't Forget `break` in switch (Causes Fall-Through)**
   ```javascript
   // BAD
   switch (color) {
       case "red":
           console.log("Red");   // Falls through!
       case "blue":
           console.log("Blue");  // Also runs!
           break;
   }
   // If color is "red", prints BOTH "Red" and "Blue"
   ```

2. **Don't Use `continue` Before Updating Counter in while**
   ```javascript
   // BAD ‚Äî infinite loop!
   let i = 0;
   while (i < 5) {
       if (i === 2) continue;  // i never increments past 2!
       console.log(i);
       i++;
   }
   ```

3. **Don't Throw Non-Error Values**
   ```javascript
   // BAD ‚Äî no stack trace
   throw "Error occurred";
   throw 404;
   throw { message: "Error" };

   // GOOD ‚Äî proper Error object
   throw new Error("Error occurred");
   throw new TypeError("Expected a string");
   ```

4. **Don't Silently Catch All Errors**
   ```javascript
   // BAD ‚Äî hides all errors
   try {
       riskyOperation();
   } catch (e) {
       // empty catch ‚Äî error is silently swallowed!
   }

   // GOOD ‚Äî at least log the error
   try {
       riskyOperation();
   } catch (e) {
       console.error("Operation failed:", e.message);
   }
   ```

5. **Don't Put `return` Value on a New Line**
   ```javascript
   // BAD ‚Äî returns undefined due to ASI!
   function bad() {
       return
       42;
   }

   // GOOD
   function good() {
       return 42;
   }
   ```

6. **Don't Use `break` or `continue` Outside of Loops/Switch**
   ```javascript
   // BAD ‚Äî SyntaxError!
   // if (condition) break;

   // break/continue only work inside loops (and break in switch)
   ```

---

## Practical Examples

### Example 1: Input Validation with break
```javascript
let inputs = ["Alice", "", "Bob", "Charlie"];
let firstEmpty = -1;

for (let i = 0; i < inputs.length; i++) {
    if (inputs[i] === "") {
        firstEmpty = i;
        break;
    }
}

console.log(firstEmpty !== -1
    ? `First empty input at index ${firstEmpty}`
    : "All inputs are filled");
// Output: First empty input at index 1
```

### Example 2: Filter with continue
```javascript
let products = [
    { name: "Laptop", price: 1200, inStock: true },
    { name: "Phone", price: 800, inStock: false },
    { name: "Tablet", price: 400, inStock: true },
    { name: "Watch", price: 200, inStock: true },
    { name: "Camera", price: 600, inStock: false }
];

console.log("Available products under $1000:");
for (let product of products) {
    if (!product.inStock) continue;      // Skip out-of-stock
    if (product.price >= 1000) continue; // Skip expensive items
    console.log(`  ${product.name} - $${product.price}`);
}
// Output:
// Available products under $1000:
//   Tablet - $400
//   Watch - $200
```

### Example 3: Safe API Call with try...catch
```javascript
async function fetchUserData(userId) {
    try {
        let response = await fetch(`/api/users/${userId}`);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        let data = await response.json();
        return data;
    } catch (error) {
        if (error.name === "TypeError") {
            console.error("Network error ‚Äî check your connection");
        } else {
            console.error(`Failed to fetch user: ${error.message}`);
        }
        return null;
    } finally {
        console.log("Fetch attempt completed");
    }
}
```

### Example 4: Retry Logic with Loops and throw
```javascript
function unreliableOperation() {
    if (Math.random() < 0.7) {
        throw new Error("Random failure");
    }
    return "Success!";
}

function retryOperation(maxRetries) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            let result = unreliableOperation();
            console.log(`Attempt ${attempt}: ${result}`);
            return result;
        } catch (error) {
            console.log(`Attempt ${attempt} failed: ${error.message}`);
            if (attempt === maxRetries) {
                throw new Error(`All ${maxRetries} attempts failed`);
            }
        }
    }
}

try {
    retryOperation(3);
} catch (error) {
    console.log(error.message);
}
```

### Example 5: All Statements Combined
```javascript
function processOrders(orders) {
    if (!Array.isArray(orders)) {
        throw new TypeError("Orders must be an array");  // throw
    }

    let processed = 0;

    for (let order of orders) {                          // loop
        if (!order.id) continue;                         // continue ‚Äî skip invalid
        if (order.cancelled) continue;                   // continue ‚Äî skip cancelled

        try {                                            // try...catch
            if (order.total <= 0) {
                throw new RangeError(`Invalid total for order ${order.id}`);
            }

            console.log(`Processing order #${order.id}: $${order.total}`);
            processed++;

            if (processed >= 3) {
                console.log("Max orders reached");
                break;                                    // break ‚Äî stop after 3
            }
        } catch (error) {
            console.log(`Skipped: ${error.message}`);
        }
    }

    return processed;                                    // return
}

let orders = [
    { id: 1, total: 50, cancelled: false },
    { id: null, total: 30, cancelled: false },
    { id: 2, total: -10, cancelled: false },
    { id: 3, total: 75, cancelled: true },
    { id: 4, total: 100, cancelled: false },
    { id: 5, total: 200, cancelled: false }
];

let count = processOrders(orders);
console.log(`Total processed: ${count}`);
// Output:
// Processing order #1: $50
// Skipped: Invalid total for order 2
// Processing order #4: $100
// Processing order #5: $200
// Max orders reached
// Total processed: 3
```

---

## Comparison Table

### All Control Transfer Statements:

| Statement | Purpose | Scope | Returns Value? |
|-----------|---------|-------|---------------|
| `break` | Exit loop or switch | Loops, Switch | ‚ùå |
| `continue` | Skip current iteration | Loops only | ‚ùå |
| `return` | Exit function | Functions only | ‚úÖ Optional |
| `throw` | Signal an error | Anywhere | ‚ùå (throws) |

### break vs continue vs return:

| Scenario | `break` | `continue` | `return` |
|----------|---------|------------|----------|
| Exits loop? | ‚úÖ Yes | ‚ùå No (skips iteration) | ‚úÖ Yes (exits function too) |
| Exits function? | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| Works in switch? | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes |
| Works without loop? | In switch only | ‚ùå No | ‚úÖ In any function |
| With labels? | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No |

### Error Handling:

| Feature | `throw` | `try...catch` | `finally` |
|---------|---------|---------------|-----------|
| Purpose | Throw an error | Catch and handle errors | Always-run cleanup |
| Required? | To signal errors | To handle errors | Optional |
| Stops execution? | ‚úÖ Yes | Catches the error | Runs regardless |

---

## Summary

### Key Takeaways:

1. **`break`** ‚Äî exits the current loop or switch statement entirely
2. **`continue`** ‚Äî skips the current iteration, moves to the next one
3. **`return`** ‚Äî exits the function and optionally returns a value
4. **`throw`** ‚Äî throws an error that can be caught with try...catch
5. Use **labels** to break/continue outer loops in nested structures
6. Always use **`break`** in switch cases to prevent fall-through
7. Place counter update **before** `continue` in while loops
8. Throw **Error objects** (not strings) for proper stack traces
9. Use **`finally`** for cleanup code that must always run
10. Use **early returns** (guard clauses) to keep code flat and readable

---

**Remember**: Control transfer statements give you fine-grained control over program flow. Use `break` to exit early, `continue` to skip, `return` to send values back, and `throw`/`try...catch` for error handling!
