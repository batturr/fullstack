# JavaScript Scope

**Scope** determines the accessibility (visibility) of variables in different parts of your code. Understanding scope is crucial for writing bug-free JavaScript code.

---

## üìë Table of Contents

1. [What is Scope?](#what-is-scope)
2. [Types of Scope](#types-of-scope)
   - [Block Scope](#1-block-scope)
   - [Function Scope](#2-function-scope)
   - [Global Scope](#3-global-scope)
3. [Lexical Scope (Static Scope)](#lexical-scope-static-scope)
4. [Scope Chain](#scope-chain)
5. [Variable Shadowing](#variable-shadowing)
6. [Closures and Scope](#closures-and-scope)
7. [Global Scope and Window Object](#global-scope-and-window-object)
8. [Strict Mode and Scope](#strict-mode-and-scope)
9. [Practical Examples](#practical-examples)
10. [Best Practices](#best-practices)
11. [Common Mistakes to Avoid](#common-mistakes-to-avoid)
12. [Scope Comparison Table](#scope-comparison-table)

---

## What is Scope?

**Scope** is the context in which variables and functions are accessible. It defines which parts of your code can see and use a particular variable.

### Why Scope Matters:
- **Prevents Naming Conflicts**: Variables in different scopes can have the same name
- **Memory Management**: Variables are cleaned up when their scope ends
- **Security**: Limits access to variables and prevents unintended modifications
- **Code Organization**: Keeps related data encapsulated

---

## Types of Scope

JavaScript has **three types of scope**:
1. **Block Scope**
2. **Function Scope**
3. **Global Scope**

---

### 1. Block Scope

**Block Scope** was introduced in **ES6 (2015)** with the `let` and `const` keywords.

#### What is a Block?
A block is code wrapped in curly braces `{}`:
```javascript
{
    // This is a block
}
```

#### Key Points:
- Variables declared with `let` or `const` inside `{}` have **block scope**
- They are only accessible within that block
- Variables declared with `var` do **NOT** have block scope

#### Examples:

**Example 1: let with Block Scope**
```javascript
{
    let x = 2;
    console.log(x);  // 2 (accessible inside block)
}
// console.log(x);  // ReferenceError: x is not defined
```

**Example 2: const with Block Scope**
```javascript
{
    const PI = 3.14159;
    console.log(PI);  // 3.14159 (accessible inside block)
}
// console.log(PI);  // ReferenceError: PI is not defined
```

**Example 3: var WITHOUT Block Scope**
```javascript
{
    var y = 5;
    console.log(y);  // 5 (accessible inside block)
}
console.log(y);  // 5 (also accessible outside block!)
```

**Example 4: if Statement Block Scope**
```javascript
if (true) {
    let message = "Hello";
    const greeting = "Hi";
    var globalVar = "Accessible";
    
    console.log(message);     // "Hello"
    console.log(greeting);    // "Hi"
    console.log(globalVar);   // "Accessible"
}

// console.log(message);     // ReferenceError
// console.log(greeting);    // ReferenceError
console.log(globalVar);      // "Accessible" (var leaks out)
```

**Example 5: for Loop Block Scope**
```javascript
// Using let (block-scoped)
for (let i = 0; i < 3; i++) {
    console.log(i);  // 0, 1, 2
}
// console.log(i);  // ReferenceError: i is not defined

// Using var (NOT block-scoped)
for (var j = 0; j < 3; j++) {
    console.log(j);  // 0, 1, 2
}
console.log(j);  // 3 (accessible outside loop!)
```

**Example 6: Nested Blocks**
```javascript
{
    let outer = "Outer block";
    {
        let inner = "Inner block";
        console.log(outer);  // "Outer block" (can access outer)
        console.log(inner);  // "Inner block"
    }
    console.log(outer);  // "Outer block"
    // console.log(inner);  // ReferenceError
}
```

---

### 2. Function Scope

**Function Scope** means variables declared inside a function are only accessible within that function.

#### Key Points:
- All variables declared inside a function (using `var`, `let`, or `const`) have function scope
- They cannot be accessed from outside the function
- Each function creates its own scope

#### Examples:

**Example 1: Function Scope with var**
```javascript
function myFunction() {
    var carName = "Volvo";  // Function Scope
    console.log(carName);   // "Volvo"
}

myFunction();
// console.log(carName);  // ReferenceError: carName is not defined
```

**Example 2: Function Scope with let**
```javascript
function calculateSum() {
    let result = 10 + 20;  // Function Scope
    console.log(result);   // 30
}

calculateSum();
// console.log(result);  // ReferenceError: result is not defined
```

**Example 3: Function Scope with const**
```javascript
function getPi() {
    const PI = 3.14159;  // Function Scope
    return PI;
}

console.log(getPi());  // 3.14159
// console.log(PI);    // ReferenceError: PI is not defined
```

**Example 4: Multiple Variables in Function**
```javascript
function userInfo() {
    var name = "John";
    let age = 30;
    const country = "USA";
    
    console.log(name, age, country);  // "John" 30 "USA"
}

userInfo();
// All three variables are inaccessible outside the function
```

**Example 5: Function Parameters are Function-Scoped**
```javascript
function greet(name) {
    // 'name' parameter is function-scoped
    console.log("Hello, " + name);
}

greet("Alice");  // "Hello, Alice"
// console.log(name);  // ReferenceError: name is not defined
```

**Example 6: Nested Functions and Scope**
```javascript
function outer() {
    let outerVar = "I'm outer";
    
    function inner() {
        let innerVar = "I'm inner";
        console.log(outerVar);  // Accessible (lexical scope)
        console.log(innerVar);  // Accessible
    }
    
    inner();
    // console.log(innerVar);  // ReferenceError
}

outer();
```

---

### 3. Global Scope

**Global Scope** applies to variables declared outside any function or block.

#### Key Points:
- Variables declared globally can be accessed from anywhere in the program
- Available throughout script execution
- All three keywords (`var`, `let`, `const`) create global variables when used outside functions
- Global `var` variables become properties of the `window` object (in browsers)

#### Examples:

**Example 1: Global Variables**
```javascript
var globalVar = "I'm global (var)";
let globalLet = "I'm global (let)";
const GLOBAL_CONST = "I'm global (const)";

function test() {
    console.log(globalVar);      // Accessible
    console.log(globalLet);      // Accessible
    console.log(GLOBAL_CONST);   // Accessible
}

test();
console.log(globalVar);          // Accessible
console.log(globalLet);          // Accessible
console.log(GLOBAL_CONST);       // Accessible
```

**Example 2: Implicit Global Variables (BAD PRACTICE)**
```javascript
function createGlobal() {
    implicitGlobal = "I'm accidentally global!";  // No var, let, or const
}

createGlobal();
console.log(implicitGlobal);  // "I'm accidentally global!" (works but BAD!)
```

**Example 3: Global Scope in HTML**
```html
<!DOCTYPE html>
<html>
<head>
    <script>
        var globalMessage = "Hello from global scope!";
    </script>
</head>
<body>
    <script>
        console.log(globalMessage);  // Accessible
    </script>
    <script src="another-file.js"></script>  <!-- Can also access globalMessage -->
</body>
</html>
```

**Example 4: Global Scope Across Multiple Scripts**
```javascript
// File: script1.js
var sharedData = "Shared across files";

// File: script2.js
console.log(sharedData);  // Accessible if script1.js loads first
```

---

## Lexical Scope (Static Scope)

**Lexical Scope** means that a function's scope is determined by where it is **written** in the code, not where it is **called**.

### Key Concept:
Inner functions have access to variables in their outer (parent) functions.

### Example 1: Basic Lexical Scope
```javascript
function outer() {
    let outerVar = "Outer";
    
    function inner() {
        console.log(outerVar);  // Can access outerVar
    }
    
    inner();
}

outer();  // "Outer"
```

### Example 2: Multiple Nesting Levels
```javascript
let global = "Global";

function level1() {
    let var1 = "Level 1";
    
    function level2() {
        let var2 = "Level 2";
        
        function level3() {
            let var3 = "Level 3";
            
            console.log(global);  // Accessible
            console.log(var1);    // Accessible
            console.log(var2);    // Accessible
            console.log(var3);    // Accessible
        }
        
        level3();
    }
    
    level2();
}

level1();
```

### Example 3: Lexical Scope with Arrow Functions
```javascript
function createCounter() {
    let count = 0;
    
    return {
        increment: () => {
            count++;       // Access outer 'count'
            console.log(count);
        },
        decrement: () => {
            count--;       // Access outer 'count'
            console.log(count);
        },
        getCount: () => count  // Access outer 'count'
    };
}

const counter = createCounter();
counter.increment();  // 1
counter.increment();  // 2
counter.decrement();  // 1
console.log(counter.getCount());  // 1
```

---

## Scope Chain

The **Scope Chain** is the hierarchy of scopes that JavaScript uses to resolve variable references.

### How It Works:
1. JavaScript first looks in the **current scope**
2. If not found, it looks in the **parent scope**
3. Continues up the chain to the **global scope**
4. If still not found, throws a **ReferenceError**

### Example 1: Scope Chain Lookup
```javascript
let global = "Global Variable";

function outer() {
    let outerVar = "Outer Variable";
    
    function inner() {
        let innerVar = "Inner Variable";
        
        console.log(innerVar);   // Found in current scope (inner)
        console.log(outerVar);   // Found in parent scope (outer)
        console.log(global);     // Found in global scope
        // console.log(notDefined);  // ReferenceError (not in scope chain)
    }
    
    inner();
}

outer();
```

### Example 2: Scope Chain Visualization
```javascript
let level0 = "Global";              // Global Scope

function level1Func() {
    let level1 = "Level 1";         // Level 1 Scope
    
    function level2Func() {
        let level2 = "Level 2";     // Level 2 Scope
        
        // Scope Chain for level2Func:
        // level2Func scope ‚Üí level1Func scope ‚Üí Global scope
        
        console.log(level2);  // Current scope
        console.log(level1);  // Parent scope
        console.log(level0);  // Global scope
    }
    
    level2Func();
}

level1Func();
```

### Example 3: Scope Chain with Same Variable Names
```javascript
let message = "Global Message";

function outer() {
    let message = "Outer Message";
    
    function inner() {
        let message = "Inner Message";
        console.log(message);  // "Inner Message" (found in current scope, stops lookup)
    }
    
    inner();
    console.log(message);  // "Outer Message"
}

outer();
console.log(message);  // "Global Message"
```

---

## Variable Shadowing

**Variable Shadowing** occurs when a variable in an inner scope has the same name as a variable in an outer scope, effectively "hiding" the outer variable.

### Example 1: Basic Shadowing
```javascript
let name = "Global Name";

function showName() {
    let name = "Local Name";  // Shadows global 'name'
    console.log(name);        // "Local Name"
}

showName();
console.log(name);  // "Global Name" (unchanged)
```

### Example 2: Shadowing in Nested Blocks
```javascript
let x = 10;

{
    let x = 20;  // Shadows outer x
    {
        let x = 30;  // Shadows both outer x variables
        console.log(x);  // 30
    }
    console.log(x);  // 20
}

console.log(x);  // 10
```

### Example 3: Function Parameter Shadowing
```javascript
let value = "Global";

function test(value) {  // Parameter 'value' shadows global 'value'
    console.log(value);  // Uses parameter, not global
}

test("Local");  // "Local"
console.log(value);  // "Global"
```

### Example 4: Cannot Shadow with var in Same Scope
```javascript
let x = 10;
// var x = 20;  // SyntaxError: Identifier 'x' has already been declared
```

---

## Closures and Scope

A **Closure** is a function that has access to variables in its outer (lexical) scope, even after the outer function has returned.

### Example 1: Basic Closure
```javascript
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;  // Accesses 'multiplier' from outer scope
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15
```

### Example 2: Closure with Private Variables
```javascript
function createBankAccount(initialBalance) {
    let balance = initialBalance;  // Private variable
    
    return {
        deposit: function(amount) {
            balance += amount;
            return balance;
        },
        withdraw: function(amount) {
            if (amount <= balance) {
                balance -= amount;
                return balance;
            }
            return "Insufficient funds";
        },
        getBalance: function() {
            return balance;
        }
    };
}

const account = createBankAccount(100);
console.log(account.deposit(50));     // 150
console.log(account.withdraw(30));    // 120
console.log(account.getBalance());    // 120
// console.log(account.balance);      // undefined (private)
```

### Example 3: Closure in Loop (Common Pitfall)
```javascript
// WRONG: Using var
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i);  // Prints 3, 3, 3 (all reference same 'i')
    }, 1000);
}

// CORRECT: Using let
for (let j = 0; j < 3; j++) {
    setTimeout(function() {
        console.log(j);  // Prints 0, 1, 2 (each has own 'j')
    }, 1000);
}

// CORRECT: Using closure with var
for (var k = 0; k < 3; k++) {
    (function(num) {
        setTimeout(function() {
            console.log(num);  // Prints 0, 1, 2
        }, 1000);
    })(k);
}
```

---

## Global Scope and Window Object

In browsers, global variables declared with `var` become properties of the `window` object.

### Example 1: var and window Object
```javascript
var globalVar = "I'm on window";
console.log(window.globalVar);  // "I'm on window"
console.log(globalVar === window.globalVar);  // true
```

### Example 2: let/const NOT on window Object
```javascript
let globalLet = "Not on window";
const GLOBAL_CONST = "Not on window";

console.log(window.globalLet);      // undefined
console.log(window.GLOBAL_CONST);   // undefined
```

### Example 3: Accessing Built-in Window Properties
```javascript
console.log(window.location);  // Current URL
console.log(window.document);  // DOM document
console.log(window.navigator); // Browser info
```

### Example 4: Potential Conflicts
```javascript
// BAD: Overwrites built-in window.name property
var name = "My Name";
console.log(window.name);  // "My Name" (overwrites window.name!)

// BETTER: Use let/const
let userName = "My Name";
// window.userName is undefined
```

---

## Strict Mode and Scope

**Strict Mode** (`'use strict'`) makes JavaScript more strict about scope and prevents common mistakes.

### Example 1: Prevents Implicit Globals
```javascript
'use strict';

function test() {
    // variable = "Oops";  // ReferenceError in strict mode
    let variable = "OK";   // Must declare explicitly
}
```

### Example 2: Strict Mode in Function
```javascript
function normalMode() {
    undeclared = 10;  // Creates implicit global (bad)
}

function strictMode() {
    'use strict';
    // undeclared = 10;  // ReferenceError in strict mode
}
```

### Example 3: Entire Script in Strict Mode
```javascript
'use strict';

// All code below runs in strict mode
function test() {
    // implicitGlobal = "Error";  // ReferenceError
}
```

---

## Practical Examples

### Example 1: Counter with Closure
```javascript
function createCounter(initialValue = 0) {
    let count = initialValue;
    
    return {
        increment() {
            return ++count;
        },
        decrement() {
            return --count;
        },
        reset() {
            count = initialValue;
            return count;
        },
        getValue() {
            return count;
        }
    };
}

const counter = createCounter(10);
console.log(counter.increment());  // 11
console.log(counter.increment());  // 12
console.log(counter.decrement());  // 11
console.log(counter.reset());      // 10
```

### Example 2: Private Methods with IIFE
```javascript
const calculator = (function() {
    // Private variables
    let result = 0;
    
    // Private method
    function log(operation, value) {
        console.log(`${operation}: ${value}`);
    }
    
    // Public methods
    return {
        add(num) {
            result += num;
            log("Add", num);
            return this;
        },
        subtract(num) {
            result -= num;
            log("Subtract", num);
            return this;
        },
        getResult() {
            return result;
        }
    };
})();

calculator.add(10).subtract(3);
console.log(calculator.getResult());  // 7
```

### Example 3: Module Pattern
```javascript
const UserModule = (function() {
    // Private variables
    let users = [];
    let nextId = 1;
    
    // Private function
    function validateUser(user) {
        return user.name && user.email;
    }
    
    // Public API
    return {
        addUser(name, email) {
            const user = { id: nextId++, name, email };
            if (validateUser(user)) {
                users.push(user);
                return user;
            }
            return null;
        },
        
        getUsers() {
            return [...users];  // Return copy
        },
        
        getUserById(id) {
            return users.find(u => u.id === id);
        }
    };
})();

UserModule.addUser("John", "john@example.com");
UserModule.addUser("Alice", "alice@example.com");
console.log(UserModule.getUsers());
```

---

## Best Practices

### ‚úÖ Do:

1. **Use Block Scope (let/const)**
   ```javascript
   // Good
   for (let i = 0; i < 10; i++) {
       // i is block-scoped
   }
   ```

2. **Minimize Global Variables**
   ```javascript
   // Good: Use modules or closures
   const app = (function() {
       let privateData = "hidden";
       return {
           getData: () => privateData
       };
   })();
   ```

3. **Declare Variables at the Top of Scope**
   ```javascript
   function calculate() {
       let x, y, result;  // Declare at top
       x = 10;
       y = 20;
       result = x + y;
   }
   ```

4. **Use Const by Default**
   ```javascript
   const MAX_SIZE = 100;
   const API_URL = "https://api.example.com";
   ```

5. **Use Strict Mode**
   ```javascript
   'use strict';
   // Rest of your code
   ```

6. **Keep Scope as Small as Possible**
   ```javascript
   // Good: Limited scope
   function process() {
       if (condition) {
           let temp = someCalculation();
           return temp * 2;
       }
   }
   ```

7. **Avoid Variable Shadowing**
   ```javascript
   // Good: Use different names
   let globalName = "Global";
   function test() {
       let userName = "User";  // Different name
   }
   ```

---

## Common Mistakes to Avoid

### ‚ùå Don't:

1. **Don't Forget to Declare Variables**
   ```javascript
   // BAD
   function bad() {
       count = 10;  // Implicit global
   }
   
   // GOOD
   function good() {
       let count = 10;
   }
   ```

2. **Don't Pollute Global Scope**
   ```javascript
   // BAD
   var data1 = "...";
   var data2 = "...";
   var helper1 = function() {};
   
   // GOOD
   const MyApp = {
       data1: "...",
       data2: "...",
       helper1: function() {}
   };
   ```

3. **Don't Use var in Loops**
   ```javascript
   // BAD
   for (var i = 0; i < 5; i++) {
       setTimeout(() => console.log(i), 100);  // Prints 5, 5, 5, 5, 5
   }
   
   // GOOD
   for (let i = 0; i < 5; i++) {
       setTimeout(() => console.log(i), 100);  // Prints 0, 1, 2, 3, 4
   }
   ```

4. **Don't Access Variables Before Declaration**
   ```javascript
   // BAD
   console.log(x);  // ReferenceError with let/const
   let x = 10;
   
   // GOOD
   let x = 10;
   console.log(x);
   ```

5. **Don't Rely on Hoisting**
   ```javascript
   // BAD (unclear)
   function confusing() {
       console.log(x);  // undefined
       var x = 10;
   }
   
   // GOOD (clear)
   function clear() {
       let x = 10;
       console.log(x);  // 10
   }
   ```

6. **Don't Shadow Important Variables**
   ```javascript
   // BAD
   let result = 0;
   function calculate() {
       let result = 10;  // Shadows outer result (confusing)
   }
   
   // GOOD
   let finalResult = 0;
   function calculate() {
       let tempResult = 10;
   }
   ```

---

## Scope Comparison Table

| Feature | Block Scope | Function Scope | Global Scope |
|---------|-------------|----------------|--------------|
| **Defined in** | `{}` blocks | Functions | Outside all functions/blocks |
| **Accessible from** | Only within block | Only within function | Everywhere |
| **Keywords** | `let`, `const` | `var`, `let`, `const` | `var`, `let`, `const` |
| **Example** | `if { let x }` | `function() { var x }` | `var x = 10;` (top level) |
| **Lifetime** | Until block ends | Until function ends | Until page unloads |
| **Best for** | Loop counters, temporary values | Function-specific data | App configuration, constants |
| **Since** | ES6 (2015) | Always | Always |

---

## Summary

### Quick Reference:

| Scope Type | When to Use | Keywords |
|------------|-------------|----------|
| **Block Scope** | Limited, temporary variables | `let`, `const` |
| **Function Scope** | Function-specific variables | `var`, `let`, `const` |
| **Global Scope** | App-wide constants, configuration | `const` (preferred) |

### Key Takeaways:

1. **Block Scope**: Variables with `let`/`const` in `{}` blocks
2. **Function Scope**: Variables declared inside functions
3. **Global Scope**: Variables declared outside all functions
4. **Lexical Scope**: Inner functions access outer variables
5. **Scope Chain**: JavaScript looks up from inner to outer scopes
6. **Closures**: Functions remember their outer scope
7. **Best Practice**: Use `const` by default, `let` when needed, avoid `var`

### Modern JavaScript Scope Best Practices:
```javascript
'use strict';  // Always use strict mode

// Minimize globals
const CONFIG = { /* ... */ };

// Use block scope
function process() {
    for (let i = 0; i < 10; i++) {
        const result = calculate(i);
        // i and result are block-scoped
    }
}

// Use closures for privacy
const module = (function() {
    let privateVar = "hidden";
    return {
        getPrivate: () => privateVar
    };
})();
```

---

**Remember**: Understanding scope is essential for writing maintainable, bug-free JavaScript code. Always prefer block scope (`let`/`const`) over function scope (`var`) in modern JavaScript!
