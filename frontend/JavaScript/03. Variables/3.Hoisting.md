# JavaScript Hoisting

**Hoisting** is JavaScript's behavior of moving declarations to the top of their scope before code execution. Understanding hoisting is crucial for avoiding bugs and writing predictable code.

---

## ðŸ“‘ Table of Contents

1. [What is Hoisting?](#what-is-hoisting)
2. [How Hoisting Works](#how-hoisting-works)
3. [Variable Hoisting](#variable-hoisting)
   - [var Hoisting](#var-hoisting)
   - [let and const Hoisting](#let-and-const-hoisting)
4. [Function Hoisting](#function-hoisting)
   - [Function Declarations](#function-declarations)
   - [Function Expressions](#function-expressions)
   - [Arrow Functions](#arrow-functions)
5. [Temporal Dead Zone (TDZ)](#temporal-dead-zone-tdz)
6. [Class Hoisting](#class-hoisting)
7. [Hoisting Order](#hoisting-order)
8. [Best Practices](#best-practices)
9. [Common Mistakes to Avoid](#common-mistakes-to-avoid)
10. [Practical Examples](#practical-examples)
11. [Comparison Table](#comparison-table)

---

## What is Hoisting?

**Hoisting** is JavaScript's default behavior of moving **declarations** to the top of their current scope (function or global) before code execution.

### Key Points:
- Only **declarations** are hoisted, not **initializations**
- Variables declared with `var` are hoisted and initialized with `undefined`
- Variables declared with `let` and `const` are hoisted but **NOT initialized** (Temporal Dead Zone)
- Function declarations are hoisted completely (both declaration and definition)
- Function expressions are hoisted as variables (depending on var/let/const)

### Conceptual Example:

**What you write:**
```javascript
console.log(x);
var x = 5;
```

**How JavaScript interprets it:**
```javascript
var x;  // Declaration hoisted
console.log(x);  // undefined
x = 5;  // Initialization stays in place
```

---

## How Hoisting Works

JavaScript execution happens in two phases:

### Phase 1: Creation Phase (Memory Allocation)
- JavaScript scans the code for declarations
- Allocates memory for variables and functions
- `var` variables are initialized with `undefined`
- `let`/`const` variables are left uninitialized (TDZ)
- Function declarations are stored completely

### Phase 2: Execution Phase
- Code is executed line by line
- Variables are assigned their values
- Functions are called

### Visual Representation:

```javascript
// Code you write
function example() {
    console.log(a);  // undefined (hoisted)
    var a = 10;
    console.log(a);  // 10
}

// How JavaScript sees it (conceptually)
function example() {
    var a;  // Declaration hoisted to top
    console.log(a);  // undefined
    a = 10;
    console.log(a);  // 10
}
```

---

## Variable Hoisting

### var Hoisting

Variables declared with `var` are:
1. **Hoisted** to the top of their scope
2. **Initialized** with `undefined`
3. Can be accessed before declaration (returns `undefined`)

#### Example 1: Basic var Hoisting
```javascript
console.log(name);  // undefined (not ReferenceError)
var name = "John";
console.log(name);  // "John"

// Interpreted as:
// var name;
// console.log(name);  // undefined
// name = "John";
// console.log(name);  // "John"
```

#### Example 2: var Hoisting in Function
```javascript
function test() {
    console.log(x);  // undefined
    var x = 10;
    console.log(x);  // 10
}

test();
```

#### Example 3: Multiple var Declarations
```javascript
console.log(a);  // undefined
console.log(b);  // undefined
console.log(c);  // undefined

var a = 1;
var b = 2;
var c = 3;

console.log(a, b, c);  // 1 2 3

// Interpreted as:
// var a, b, c;
// console.log(a);  // undefined
// console.log(b);  // undefined
// console.log(c);  // undefined
// a = 1;
// b = 2;
// c = 3;
// console.log(a, b, c);  // 1 2 3
```

#### Example 4: var Hoisting with Scope
```javascript
var globalVar = "Global";

function outer() {
    console.log(globalVar);  // undefined (local shadows global)
    var globalVar = "Local";
    console.log(globalVar);  // "Local"
}

outer();
console.log(globalVar);  // "Global" (unchanged)

// Interpreted as:
// function outer() {
//     var globalVar;  // Hoisted, shadows global
//     console.log(globalVar);  // undefined
//     globalVar = "Local";
//     console.log(globalVar);  // "Local"
// }
```

#### Example 5: var Declaration Without Initialization
```javascript
console.log(x);  // undefined
var x;
console.log(x);  // undefined
x = 100;
console.log(x);  // 100
```

---

### let and const Hoisting

Variables declared with `let` and `const` are:
1. **Hoisted** to the top of their block
2. **NOT initialized** (remain in Temporal Dead Zone)
3. **Cannot** be accessed before declaration (throws ReferenceError)

#### Example 1: let Hoisting (Temporal Dead Zone)
```javascript
// console.log(name);  // ReferenceError: Cannot access 'name' before initialization
let name = "Alice";
console.log(name);  // "Alice"
```

#### Example 2: const Hoisting
```javascript
// console.log(PI);  // ReferenceError: Cannot access 'PI' before initialization
const PI = 3.14159;
console.log(PI);  // 3.14159
```

#### Example 3: let in Block Scope
```javascript
function test() {
    // console.log(x);  // ReferenceError (TDZ)
    
    if (true) {
        // console.log(y);  // ReferenceError (TDZ)
        let y = 20;
        console.log(y);  // 20
    }
    
    let x = 10;
    console.log(x);  // 10
}

test();
```

#### Example 4: let vs var Hoisting Comparison
```javascript
// With var (works but returns undefined)
console.log(varVariable);  // undefined
var varVariable = "var";

// With let (throws error)
// console.log(letVariable);  // ReferenceError
let letVariable = "let";
```

#### Example 5: const Must Be Initialized
```javascript
// var x;  // OK - can declare without initializing
// let y;  // OK - can declare without initializing
// const z;  // SyntaxError: Missing initializer in const declaration

const z = 10;  // Must initialize
```

---

## Function Hoisting

### Function Declarations

**Function declarations** are completely hoisted (both declaration and definition).

#### Example 1: Basic Function Hoisting
```javascript
greet();  // "Hello!" - Works!

function greet() {
    console.log("Hello!");
}
```

#### Example 2: Function Declaration Hoisting Order
```javascript
console.log(add(5, 3));  // 8 - Works!

function add(a, b) {
    return a + b;
}
```

#### Example 3: Function Overwriting
```javascript
console.log(test());  // "Second" - Last declaration wins

function test() {
    return "First";
}

function test() {
    return "Second";
}
```

#### Example 4: Function Declaration in Block (Note: behavior varies)
```javascript
// Strict mode
'use strict';

if (true) {
    function blockFunction() {
        return "Block scoped";
    }
}

// blockFunction();  // ReferenceError in strict mode
```

---

### Function Expressions

**Function expressions** are NOT hoisted as functions; they're hoisted as variables.

#### Example 1: var Function Expression
```javascript
// console.log(greet());  // TypeError: greet is not a function
// console.log(greet);    // undefined

var greet = function() {
    return "Hello!";
};

console.log(greet());  // "Hello!"

// Interpreted as:
// var greet;  // Hoisted as variable
// console.log(greet());  // TypeError (greet is undefined, not a function)
// greet = function() { return "Hello!"; };
```

#### Example 2: let Function Expression
```javascript
// console.log(calculate);  // ReferenceError (TDZ)

let calculate = function(x) {
    return x * 2;
};

console.log(calculate(5));  // 10
```

#### Example 3: const Function Expression
```javascript
// console.log(multiply);  // ReferenceError (TDZ)

const multiply = function(a, b) {
    return a * b;
};

console.log(multiply(3, 4));  // 12
```

#### Example 4: Named Function Expression
```javascript
// console.log(factorial);  // ReferenceError (with let/const)

const factorial = function fact(n) {
    if (n <= 1) return 1;
    return n * fact(n - 1);  // Can use 'fact' inside
};

console.log(factorial(5));  // 120
// console.log(fact(5));    // ReferenceError: fact is not defined
```

---

### Arrow Functions

**Arrow functions** are function expressions, so they follow the same hoisting rules as function expressions.

#### Example 1: Arrow Function with var
```javascript
// console.log(greet());  // TypeError: greet is not a function
// console.log(greet);    // undefined

var greet = () => "Hello!";
console.log(greet());  // "Hello!"
```

#### Example 2: Arrow Function with const
```javascript
// console.log(add);  // ReferenceError (TDZ)

const add = (a, b) => a + b;
console.log(add(2, 3));  // 5
```

#### Example 3: Arrow Function in Object Method
```javascript
const obj = {
    value: 42,
    // Arrow function doesn't hoist differently
    getValue: () => {
        // console.log(this.value);  // undefined (arrow function 'this')
    }
};
```

---

## Temporal Dead Zone (TDZ)

The **Temporal Dead Zone (TDZ)** is the period between entering a scope and the actual declaration where a variable cannot be accessed.

### Key Points:
- Applies to `let`, `const`, and `class`
- Variables exist but are uninitialized
- Accessing them causes ReferenceError
- TDZ ends when variable is declared

### Example 1: Visual TDZ
```javascript
{
    // TDZ starts for 'x'
    // console.log(x);  // ReferenceError: Cannot access 'x' before initialization
    // console.log(y);  // ReferenceError: Cannot access 'y' before initialization
    
    let x = 10;  // TDZ ends for 'x'
    console.log(x);  // 10
    
    const y = 20;  // TDZ ends for 'y'
    console.log(y);  // 20
}
```

### Example 2: TDZ with typeof
```javascript
// typeof is safe with undeclared variables
console.log(typeof undeclaredVar);  // "undefined" - no error

// But NOT safe with let/const in TDZ
// console.log(typeof declaredVar);  // ReferenceError
let declaredVar = "value";
```

### Example 3: TDZ in Parameters
```javascript
// function defaultValue(x = y, y = 10) {  // ReferenceError: y is in TDZ
//     return x + y;
// }

function defaultValueCorrect(y = 10, x = y) {  // OK: y is declared before x
    return x + y;
}

console.log(defaultValueCorrect());  // 20
```

### Example 4: TDZ in Nested Scopes
```javascript
let x = 10;

function test() {
    // console.log(x);  // ReferenceError (local x in TDZ)
    let x = 20;  // Local x shadows outer x
    console.log(x);  // 20
}

test();
```

### Example 5: No TDZ with var
```javascript
{
    console.log(varVariable);  // undefined (no TDZ)
    var varVariable = "var";
    
    // console.log(letVariable);  // ReferenceError (TDZ)
    let letVariable = "let";
}
```

---

## Class Hoisting

**Classes** are hoisted like `let` and `const` (Temporal Dead Zone applies).

### Example 1: Class Declaration Hoisting
```javascript
// const obj = new MyClass();  // ReferenceError: Cannot access 'MyClass' before initialization

class MyClass {
    constructor(name) {
        this.name = name;
    }
}

const obj = new MyClass("Test");
console.log(obj.name);  // "Test"
```

### Example 2: Class Expression Hoisting
```javascript
// const obj = new MyClass();  // ReferenceError (TDZ)

const MyClass = class {
    constructor(value) {
        this.value = value;
    }
};

const obj = new MyClass(42);
console.log(obj.value);  // 42
```

### Example 3: Class vs Function Declaration
```javascript
// Function declaration - hoisted completely
const dog = new Animal("Dog");  // Works!

function Animal(name) {
    this.name = name;
}

// Class declaration - TDZ
// const cat = new Pet("Cat");  // ReferenceError

class Pet {
    constructor(name) {
        this.name = name;
    }
}
```

---

## Hoisting Order

When multiple declarations exist, JavaScript hoists them in this order:

### 1. Function Declarations (highest priority)
### 2. Variable Declarations (var)
### 3. Variable Initializations (in execution phase)

### Example 1: Function vs Variable Hoisting
```javascript
console.log(foo);  // [Function: foo]

var foo = "variable";
function foo() {
    return "function";
}

console.log(foo);  // "variable"

// Interpreted as:
// function foo() { return "function"; }  // Function hoisted first
// var foo;  // Variable declaration ignored (already exists)
// console.log(foo);  // [Function: foo]
// foo = "variable";  // Initialization overwrites
// console.log(foo);  // "variable"
```

### Example 2: Multiple Functions and Variables
```javascript
console.log(test);  // [Function: test] - last function wins

var test = "variable";
function test() { return 1; }
function test() { return 2; }

console.log(test);  // "variable"

// Hoisting order:
// 1. function test() { return 1; }
// 2. function test() { return 2; }  // Overwrites first
// 3. var test;  // Ignored (function already declared)
// 4. console.log(test);  // [Function: test]
// 5. test = "variable";  // Overwrites function
// 6. console.log(test);  // "variable"
```

### Example 3: Nested Scope Hoisting
```javascript
var x = "global";

function outer() {
    console.log(x);  // undefined (local x hoisted)
    
    var x = "outer";
    
    function inner() {
        console.log(x);  // undefined (inner x hoisted)
        var x = "inner";
        console.log(x);  // "inner"
    }
    
    inner();
    console.log(x);  // "outer"
}

outer();
console.log(x);  // "global"
```

---

## Best Practices

### âœ… Do:

1. **Declare Variables at the Top of Their Scope**
   ```javascript
   function calculate() {
       let x, y, result;  // Declare at top
       x = 10;
       y = 20;
       result = x + y;
       return result;
   }
   ```

2. **Use let and const Instead of var**
   ```javascript
   // Good
   let counter = 0;
   const MAX = 100;
   
   // Avoid
   // var counter = 0;
   ```

3. **Declare Functions Before Use (Even Though Hoisted)**
   ```javascript
   // Good - clear and readable
   function greet(name) {
       return `Hello, ${name}`;
   }
   
   console.log(greet("Alice"));
   ```

4. **Use Function Expressions with const**
   ```javascript
   const calculateTotal = (items) => {
       return items.reduce((sum, item) => sum + item.price, 0);
   };
   ```

5. **Enable Strict Mode**
   ```javascript
   'use strict';
   
   // Catches more errors, prevents some hoisting issues
   ```

6. **Initialize Variables When Declaring**
   ```javascript
   // Good
   let count = 0;
   const PI = 3.14159;
   
   // Avoid
   // let count;  // uninitialized
   ```

7. **Use ESLint to Catch Hoisting Issues**
   ```javascript
   // ESLint rules:
   // "no-use-before-define": "error"
   // "no-var": "error"
   ```

---

## Common Mistakes to Avoid

### âŒ Don't:

1. **Don't Rely on var Hoisting**
   ```javascript
   // BAD - unclear and error-prone
   console.log(name);  // undefined
   var name = "John";
   
   // GOOD - clear intent
   let name = "John";
   console.log(name);  // "John"
   ```

2. **Don't Access Variables Before Declaration**
   ```javascript
   // BAD
   // console.log(value);  // ReferenceError
   let value = 10;
   
   // GOOD
   let value = 10;
   console.log(value);
   ```

3. **Don't Mix Function Declarations and Expressions**
   ```javascript
   // BAD - confusing
   var func1 = function() { return 1; };
   function func2() { return 2; }
   
   // GOOD - consistent style
   const func1 = () => 1;
   const func2 = () => 2;
   ```

4. **Don't Depend on Hoisting for Control Flow**
   ```javascript
   // BAD - relies on hoisting
   if (condition) {
       var x = 10;  // Hoisted out of if block
   }
   console.log(x);  // undefined or 10
   
   // GOOD - clear scope
   let x;
   if (condition) {
       x = 10;
   }
   console.log(x);
   ```

5. **Don't Use Function Declarations in Blocks (Non-Strict)**
   ```javascript
   // BAD - behavior undefined
   if (true) {
       function test() { return "block"; }
   }
   
   // GOOD - use function expression
   let test;
   if (true) {
       test = function() { return "block"; };
   }
   ```

6. **Don't Forget TDZ with let/const**
   ```javascript
   // BAD
   function getValue() {
       // return value;  // ReferenceError (TDZ)
       let value = 10;
       return value;
   }
   
   // GOOD
   function getValue() {
       let value = 10;
       return value;
   }
   ```

---

## Practical Examples

### Example 1: Quiz - What's the Output?

```javascript
var a = 1;
function test() {
    console.log(a);  // What prints here?
    var a = 2;
    console.log(a);  // What prints here?
}
test();
console.log(a);  // What prints here?

// Answer:
// undefined (local 'a' is hoisted but not initialized)
// 2 (local 'a' is initialized)
// 1 (global 'a' is unchanged)
```

### Example 2: Hoisting with Loops

```javascript
// With var (common mistake)
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i);  // 3, 3, 3
    }, 100);
}

// With let (correct)
for (let j = 0; j < 3; j++) {
    setTimeout(function() {
        console.log(j);  // 0, 1, 2
    }, 100);
}
```

### Example 3: Function Hoisting Priority

```javascript
console.log(typeof foo);  // "function"

var foo = "I'm a variable";
function foo() {
    return "I'm a function";
}

console.log(typeof foo);  // "string"

// Explanation:
// 1. Function declaration hoisted first
// 2. Variable declaration ignored (foo already exists)
// 3. Variable initialization overwrites function
```

### Example 4: Real-World Pattern (IIFE)

```javascript
// Avoid hoisting issues with IIFE
(function() {
    'use strict';
    
    // All variables declared at top
    let data = [];
    const API_URL = "https://api.example.com";
    
    // Functions defined before use
    function fetchData() {
        // Implementation
    }
    
    function processData() {
        // Implementation
    }
    
    // Execution
    fetchData();
})();
```

### Example 5: Module Pattern

```javascript
const MyModule = (function() {
    // Private variables (avoid hoisting issues)
    let privateVar = "private";
    
    // Private function (declared before return)
    function privateFunction() {
        return privateVar;
    }
    
    // Public API
    return {
        getPrivate: function() {
            return privateFunction();
        }
    };
})();

console.log(MyModule.getPrivate());  // "private"
```

---

## Comparison Table

| Feature | var | let | const | Function Declaration | Function Expression | Arrow Function | Class |
|---------|-----|-----|-------|----------------------|---------------------|----------------|-------|
| **Hoisted** | âœ… Yes | âœ… Yes | âœ… Yes | âœ… Yes | âœ… Yes (as variable) | âœ… Yes (as variable) | âœ… Yes |
| **Initialized on Hoist** | âœ… Yes (`undefined`) | âŒ No (TDZ) | âŒ No (TDZ) | âœ… Yes (completely) | Depends on var/let/const | Depends on var/let/const | âŒ No (TDZ) |
| **Can Access Before Declaration** | âœ… Yes (`undefined`) | âŒ No (ReferenceError) | âŒ No (ReferenceError) | âœ… Yes | âŒ Depends | âŒ Depends | âŒ No (ReferenceError) |
| **TDZ** | âŒ No | âœ… Yes | âœ… Yes | âŒ No | Depends | Depends | âœ… Yes |
| **Best Practice** | âŒ Avoid | âœ… Use | âœ… Use (preferred) | âœ… Use | âœ… Use with const | âœ… Use with const | âœ… Use |

---

## Summary

### Key Takeaways:

1. **var is hoisted** and initialized with `undefined`
2. **let and const are hoisted** but remain in TDZ (uninitialized)
3. **Function declarations** are hoisted completely (can be called before declaration)
4. **Function expressions** are hoisted as variables (behavior depends on var/let/const)
5. **Arrow functions** follow the same rules as function expressions
6. **Classes** are hoisted like let/const (TDZ applies)
7. **Always declare before use** for cleaner, more predictable code

### Modern JavaScript Best Practices:

```javascript
'use strict';  // Enable strict mode

// Declare all variables at the top of their scope
function myFunction() {
    const MAX_SIZE = 100;
    let counter = 0;
    let result;
    
    // Functions can be declared or expressed
    function helperFunction() {
        // Implementation
    }
    
    // Or use const with arrow functions
    const calculate = () => {
        // Implementation
    };
    
    // Execute logic
    helperFunction();
    result = calculate();
    
    return result;
}
```

### Quick Decision Guide:

| Situation | Use |
|-----------|-----|
| Need a function that can be called before definition | Function Declaration |
| Need a function assigned to variable | Arrow Function with const |
| Need a variable that can change | let |
| Need a constant value | const |
| Working with legacy code | Understand var hoisting |

---

**Remember**: While JavaScript hoists declarations, it's best practice to **declare all variables and functions before using them** for cleaner, more maintainable, and less error-prone code!
